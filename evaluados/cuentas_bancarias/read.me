----DESAFÍO EVALUADO CUENTAS BANCARIAS---Introduccion a objetos, Ruby---

En este desafío se presentan 2 ejercicios, cuyo objetivo es crear clases a partir de diagramas UML.

El primer ejercicio, solicita crear las clases CuentaBancaria y Usuario, mienrtras que el segundo ejercicio pide 
crear las clases Barajas y Carta.

En este README, primero se explicará, la forma de probar las clases del ejercicio 1 y luego como probar las clases del ejerciccio 2.
Posteriormente, se revisará la caja negra de cada una de las clases creadas. 


---EJERCICIO 1 CUENTAS BANCARIAS---

Crear las clases Usuario y CuentaBancaria. 
Crear el constructor de la clase CuentaBancaria que reciba el nombre del banco, el
número de cuenta y el saldo (el saldo por defecto será cero). 
Crear el método transferir en la clase Cuenta que reciba un monto y otra cuenta. Este
método restará del saldo actual el monto y aumentará el saldo de la otra cuenta en el mismo
monto. 
Probar creando dos cuentas cada una con un saldo de 5000 y transferir el total de una
cuenta a la otra.
Crear el constructor de Usuario que reciba el nombre del usuario y un arreglo con al
menos 1 cuenta bancaria. (


Para probar codigo, que da solución a estos requerimientos, se debe ingresar al irb y requerir 
el archivo cuentas_bancarias esto se hace a traves de:

require_relative 'cuentas_bancarias.rb'

el archivo cuentas_bancarias lo que hace es requerir 2 archivos, en los cuales se cren las clases CuentaBancaria y usuarios.
Ademas, de requerir el archivo tester_cuentas.rb. el cual se hizo para probar las clases de forma más automática.  

#archivo Cuentas_Bancarias ccontiene. 
    require_relative 'cuentaBancaria.rb'
    require_relative 'usuario.rb'
    require_relative 'tester_cuentas.rb'

una vez cargado el archivo. se puede probar de forma automática las clases escribiendo en el irb main.

para probar las clases manualmente se debe instanciar cada una de las clases.  

para crear una cuenta nueva: en irb:  cuenta1 = CuentaBancaria.new('nombreBanco','numeroCuenta',saldo)

---El atributo nombreBanco debe pertenecer a la clase String.
---El atributo numeroCuenta debe pertenecer a la clase String. No obstante, debe ingresar solo digitos y su tamaño debe ser de 8 digitos
---El atributo saldo debe pertenecer a la clase Integer.

Para crear un usuario nuevo se puede hacer de 2 formas.
    a) crear al usuario con una cuenta

    en irb:    cliente1 = Usuario.new('nombreCliente',cuenta1)

---El atributo nombreCliente debe pertenecer a la clase String
---El atributo cuenta1 debe pertenecer a la clase CuentaBancaria

    b) crear al usuario con un arreglo de cuentas 

    en irb:
        cuentaArray = []
        cuentaArray.push(cuenta1,cuenta2)
        cliente1 = Usuario.new('nombreCliente',cuentaArray)


---El atributo nombreCliente debe ser de la clase String
---El atributo cuentaArray es de la clase array. Pero sus elementos deben ser de la clase CuentaBancaria.

Mientras se instancian las cuentas y los usuarios, se pueden probar las excepciones y validadciones.
Una vez instanciadas las cuentas y los usuarios se pueden probar los metodos de instancia.

-----METODO transferir en CuentaBancaria

Lo que hace este metodo, es validar si la cuenta1 tiene el saldo suficiente para transferir a cuenta2. Y si es así,
transfiere la cantidad indicada en el atributo monto. Es decir, al saldo de cuenta1 le resta el monto y al saldo de 
cuenta2, le suma el monto.
    
    en irb:
    cuenta1.transferir(cuenta2,monto)

---El atributo cuenta2 es de la clase CuentaBancaria
---El atributo monto es de la clase Integer



-----METODO sumarSaldos en usuarios

Este metodo de instancia, suma los saldos de todas las cuentas asociadas a un cliente(usuario)
    
    en irb:
    cliente1.SumarSaldos


-----METODO agregar_cuenta
Si bien este metodo no fue requerido, se creó para poder agregar cuentas y poder probar el metodo sumarSaldos.
Lo primero que hace, es validar si la cuenta existe y sino existe la crea. Luego, toma los saldos de cada cuenta 
asociada a un cliente y los suma. 

    en irb:
    cliente.agregar_cuenta


---EJERCICIO 2  BARAJA DE CARTAS---

Crear la clase carta con los atributos numero y pinta.
Agregar los getters y setters a ambos atributos.
Crear el constructor de la clase carta que le permita recibir un número del 1 al 13 y la
pinta que está indicada por una sola letra. Puede ser Corazón: 'C', Diamante: 'D', Espada: 'E' o Trébol: 'T'.
Utilizar el ejercicio Carta creado en la primera parte y dejarlo en el archivo carta.rb.
Crear la clase baraja en el archivo barajas.rb con el atributo cartas, el cual será un arreglo.
Al crear una baraja (constructor) se deben generar todas las combinaciones de
números y pinta y guardarse dentro del arreglo cartas.
Crear el método barajar que debe desordenar el arreglo de cartas Tip: Utilizar .shuffle.
Crear el método sacar que permita retirar la primera carta de la baraja Tip: Utilizar .pop.
Crear el método repartir mano que devolverá un arreglo con las primeras 5 cartas de la baraja.

La solucion a estos requerimientos se encuentran en el archivo barajas.rb
Tal y como se hizo en el ejercicio 1, para hacer las pruebas correspondientes, se debe ingresar al irb.

en irb: require_relative 'barajas'

una vez cargado el archivo, se pueden probar las clases de forma automatica o de forma manual.

---Para probar de forma automática: 

        en irb: main

---Para probar de forma manual:

La clase Carta, se puede instanciar creando cartas individuales a gusto del usuario. No obstante, serian cartas huachas,
que no pertenecen a ninguna baraja.

    en irb: carta1 = Carta.new(1,"C")

    de esta forma se estaría creando el AS de corazón 

obviamente, se hacen las validaciones correspondientes. Por lo cual, el primer atributo que corresponde al numero de carta
debe ser entre 1 y 13 y el segundo atributo, que corresponde a la pinta debe ser una letra y la correspondencia es la siguiente:

    "C" = Corazón
    "D" = Diamante
    "E" = Espada o Pica para los chilenos
    "T" = Trebol 

Entonces, como se dijo anteriormente, crear las cartas de esta forma, lleva a que sean cartas que no pertenecen a ninguna baraja.
Por tanto, para poder crear un mazo de cartas hay que instanciar la clase Barajas.

    en irb: barajaNueva1 = Baraja.new

Al instanciar la clase baraja, se crea automaticamente un mazo de cartas con todos los numeros y pintas correspondiente.

Además, ofrece la posibilidad de barajar el mazo, sacar una carta y reordenarlo (esto no estaba en lo requerimientos, pero me pareció necesario).

    para barajar el mazo.  en irb: barajaNueva1.barajar

una vez barajado el mazo se puede rapartir manos de 5 cartas. 

    en irb: barajaNueva1.repartirMano

para sacar una carta del mazo.

    en irb: barajaNueva1.sacar


la cantidad de veces que se puede ejecutar el metodo repartirMano y el metodo sacar esta limitado por la cantidad de cartas que quedan
en la baraja. una vez que se acaban las cartas. es necesario reordernar la baraja para poder repartir y/o sacar cartas.
Por esto se creo el metodo ordenar.

    en irb: baraja1.ordenar



---REVISANDO LA CAJA NEGRA---

Para poder saber como hace lo que hace cada clase y cada metodo es necesario entrar en la caja negra. 
Con una explicación breve y sencilla vamos a mostrarla por dentro.

EXPLICACIÓN  ---Primer Ejercicio---

1.- En este desafio se pide crear las clases Usuario y CuentaBancaria.

    Esto lo hacemos de la siguiente manera:

    class CuentaBancaria
    end 

    class Usuario
    end 

2.- Crear el constructor de la clase CuentaBancaria que reciba el nombre del banco, el
    número de cuenta y el saldo (el saldo por defecto será cero). 

    El siguiente codigo permite crear el constructor de la clase CuentaBancaria. Más adelante se agregarán,
    las attr, excepciones y validaciones.

    def initialize(banco,cuenta,saldo=0)
        @banco = banco
        @cuenta = cuenta
        @saldo = saldo
    end

    nota: saldo=0 indica que si no se pasa este parametro asumira como valor inicial el valor 0

3.- Crear el método transferir en la clase Cuenta que reciba un monto y otra cuenta. Este
    método restará del saldo actual el monto y aumentará el saldo de la otra cuenta en el mismo
    monto. 

    En este punto se incluyen algunas validaciones, que son importantes para que el metodo transferir se ejecute
    sin problema.

    #--- En la linea siguiente, se crea el metodo transferir, al cual se le pasa una cuenta de la clase CuentaBancaria 
        y un monto.

    def transferir(cuenta2,monto) 
    
    #------en el siguiente bloque de codigo, se validan 3 excepciones:
        a) primero, se valida si el atributo cuenta pertenece a la clase CuentaBancaria, y sino es así se levanta una excepción
            de tipo ArgumentError. 
        b) Segundo, se valida si el atributo monto es de la clase integer. De no serlo se levante la excepción de tipo
            ArgumentError
        c) tercero se valida si el atributo monto es menor que cero. en caso de serlo levanta una excepción de tipo 
            RangeError indicando que no se puede ingresar un numero negativo.

      raise ArgumentError,'El atributo cuenta debe ser de la clase CuentaBancaria' if cuenta2.class != CuentaBancaria # valida si contiene algun carácter que no sea un número
      raise ArgumentError,'El atributo monto debe ser de la clase integer' if monto.class != Integer
      raise RangeError, 'El atributo monto no puede ser negativo ' if monto < 0
    #---------------

    Luego de validar las excepciones, se valida si los atributos tienen las cantidades suficientes para realizar la transacción.
    Solo en caso de que el saldo de la cuenta que recibe los datos sea mayor que el monto a transferir, se realiza la transferencia.
  
    return "Saldo insuficiente" if @saldo < monto
    return "El monto debe ser mayor que cero" if monto == 0
      if @saldo >= monto
      @saldo -= monto
      cuenta2.saldo += monto
      return "Transferencia aprobada"    # return print "saldo cuenta1 #{@saldo}  #{cuenta2.saldo}" 
    end
    end

    Para poder acceder a los atributos que se utilizan en la ejecución de los metodos de instancia, es necesario agregar los attr.
    y eso se hace de la siguiente manera.

    Cuando se crea la instancia, agregamos las siguientes 2 lineas, antes del metodo constructor:

    classs CuentaBancaria
    attr_reader :banco, :cuenta
    attr_accessor :saldo

    Lo que permite attr_reader es, acceder en modo lectura a los atributos :banco y :cuenta
    y attr_accessor permite acceder al atributo :saldo, tanto en modo lectura como en modo escritura. 
    Gracias a eso podemos modificar su contenido. 

    Finalmente para completar la clase CuentaBancaria, se validan las excepciones, en el metodo constructor.
    Primero se valida, que los atributos banco y cuenta pertenezcan a la clase String. Además se evalua, que en 
    el atributo cuenta, que a pesar de ser un string se ingresen solo numeros. Tambien se valida que el atributo saldo 
    pertenezca a la clase integer. En todos estos casos se levanta una excepción de tipo ArgumentError.
    Tambien en caso de que el atributo cuenta, tenga un largo inferior o superior a 8 digitos y en le atributo saldo se ingrese
    un numero negativo, se levanta la excepcion de tipo RangeError.  

def initialize(banco,cuenta,saldo=0)
    
    #***validadación de excepciones
    raise ArgumentError, 'El atributo banco debe ser de la clase string' if banco.class != String
    raise ArgumentError, 'El atributo cuenta debe ser de la clase string' if cuenta.class != String
    raise ArgumentError,'ingrese solo digitos en el atributo cuenta' if cuenta.match(/\D/).nil? == false # valida si contiene algun carácter que no sea un número
    raise ArgumentError,'El atributo saldo debe ser de la clase integer' if saldo.class != Integer
    raise RangeError, 'El largo del atributo cuenta debe se de 8 digitos' if cuenta.length != 8
    raise RangeError, 'El atributo saldo no puede ser negativo ' if saldo < 0


    @banco = banco
    @cuenta = cuenta
    @saldo = saldo
  end

Como se puede ver, una vez validada las excepciones, el metodo constructor asigna los atributos ingresados a las variables de instancia.

La Clase CuentaBancaria está lista para ser instanciada.


---LA CLASE USUARIO---

Anteriormente se había creado la clase Usuario. Por tanto, se revisará el metodo constructor y los metodos sumar saldo y agregar cuenta

Antes de revisar el metodo constructor, revisemos los metodos attr.

Para poder acceder a las variables de instancia se establece de que modo se accederá a ellas.

    attr_reader :usuario   #modo lectura
    attr_accessor :cuentas  #modo lectura y escritura

En el metodo costructor validamos las excepciones :

    def initialize (usuario, cuentas)
    raise ArgumentError, 'El atributo usuario debe ser de la clase string' if usuario.class != String
    raise ArgumentError, 'El atributo cuenta debe ser de la clase array o de la clase CuentaBancaria' if cuentas.class != Array && cuentas.class != CuentaBancaria

se crea una variable de la clase Array, en la cual se almacenarán las cuentas asociadas al usuario. 

    cuentaArray = Array.new

Notese que es importante recordar que el tipo de cuenta ingresado, puede ser de la clase CuentaBancaria o de la Clase Array  es por esto que una de las 
excpeciones validadas es precisamennte la clase a la cual pertenece el atributo cuentas.

Pero aquí hay una consideración importante. Si el atributo cuentas pertenece a la clase Array eventualmente dentro del arreglo podria cometerse el 
error de ingresar un String con el numero de cuenta. El cual no será validado por la excepción dado que está dentro del arreglo, es decir habria pasado camuflado.

        ejemplos de ingreso del atributo cuentas

       caso 1 cuentaArray1 = [cuenta1, cuenta2] 
       caso 2 cuentaArray2 = [cuenta3, "12345678"]
       
       Cliente1 = Usuario.new('carlos',cuenta4)
       Cliente2 = Usuario.new('Marta',cuentaArray1)
       Cliente3 = Usuario.new('Alexis',cuentaArray2)

Supongamos que las cuentas 1, 2, 3 y 4 ya fueron instanciadas. 

Al analizar los 3 casos, todos pasarían el primer cortafuegos.


    caso 1 cuenta4 pertenece a la clase CuentaBancaria por tanto pasa la excepción

    caso 2 cuentaArray1 contiene Cuenta1 y Cuenta2 ambas pertenecen a la clase CuentaBancaria pero cuentaArray es
        de la clase Array por tanto pasa la excepción si problema.

    caso3 cuentaArray2 es de la clase Array, por tanto sortea la primera excepción sin problemas. aunque la cuenta con el numero ingresado en el string
        no haya sido creada. 
        Para solucionar este problema se debe validar que los elementos del atributo Cuentas, cuando se ingrese un Array con varias cuentas,
        pertenezcan todos a la clase CuentaBancaria. sino es así, significa que la cuenta no existe.
    
            if cuentas.class == Array
                cuentas.each do |cuentaIngresada|
                if cuentaIngresada.class != CuentaBancaria
                    raise ArgumentError, 'El atributo cuenta debe ser de la clase array o de la clase CuentaBancaria'
                else
                    cuentaArray.push(cuentaIngresada)

                end
            elsif cuentas.class == CuentaBancaria
                cuentaArray.push(cuentas)
            end
    
    En estas lineas de codigo, en el caso que se haya ingresado un arreglo, se recorre  validando que cada elemento pertenezca a la clase CuentaBancaria.
    En caso de que no pertenezca envia un excepción.
    pero si pertenece, traspasa la cuenta a la variable cuentaArray.
    Y en el caso de que se haya ingresado pushea la cuenta en cuentaArray.

    posterior a eso asignas los atributos ingresado a las variables de instancia. 

    @usuario = usuario
    @cuentas = cuentaArray

---EL METODO sumarSaldos---

Primero, que todo, se inicializa la variable saldoTotal en 0 y luego se trabaja sobre la variable de instancia @cuentas
La variable @cuentas, es de la clase Array dado que el atributo cuenta que se ingresa, una vez validado, se asigna al arreglo arrayCuenta.
El cual posteriormente se asigna a traves del signo = a la variable de instancia @cuentas la cual adquiere la clase Array

    saldoTotal = 0
    @cuentas.each do |cuentaUsuario|
      saldoTotal = saldoTotal + cuentaUsuario.saldo
    end
    return saldoTotal 

luego recorremos los elementos que contiene @cuentas que son todos de la clase CuentaBancaria. por lo cual accedemos 
al atributo saldo, el cual se suma a la variable saldoTotal. 

---EL METODO agregar_cuenta

Este método, como dije antes, se agregó para poder agregar cuentas y probar el metodo sumar Saldos. Por lo mismo, solo permite agregar
cuentas de la clase CuentaBancaria. una a la vez.

lo primero que hace es validad si la cuenta existe. En caso de que no exista la pushea a la variable de instancia @cuentas. en caso de existir
envia un mesnaje que la cuenta ya existe.

def agregar_cuenta(cuenta3)
    cuentaExiste = false
    raise ArgumentError,'El atributo cuenta debe ser de la clase CuentaBancaria' if cuenta3.class != CuentaBancaria # valida si contiene algun carácter que no sea un número
    @cuentas.include?(cuenta3) ? cuentaExiste = true : cuentaExiste = false
    if cuentaExiste == true
      return "La cuenta ya existe"
    else
      @cuentas.push(cuenta3)
      return "La cuenta fue agregada con exito"
    end
  end 


---LA CAJA NEGRA DE LAS CLASES Carta y Baraja---

Primero se cren las clases.

class Carta
end

class Baraja
end

luego se habilitan los metodos attr

class Carta
    attr_reader :numero, :pinta    #modo lectura
    attr_writer :numero, :pinta    #modo escritura
end

---EL METODO CONSTRUCTOR DE LA CLASE Carta---
 básicamente valida las excepciones y asigna las variables de instancia.
def initialize(numero, pinta)
    pintas = ["C", "D", "E", "T"]
    raise RangeError, 'El numero debe estar entre el rango 1 y 13' if numero < 1 || numero > 13
    raise ArgumentError, 'el Argumento numero no es valido, debe ser integer' if numero.class != Integer
    raise ArgumentError, 'el argumento pinta debe ser solo una letra'  if pinta.length != 1
    raise ArgumentError, 'Argumento no valido C=Corazón D=Diamante E=Espada T=Trebol'  if pintas.include?(pinta.upcase) == false
    @numero = numero
    @pinta = pinta.upcase
  end

  La clase Carta contiene un metodo que cambia la letra que representa a la pinta por el nombre largo de la pinta.
  
  def nombreCarta
    return "Corazón" if @pinta == "C"
    return "Diamante" if @pinta == "D"
    return "Espada" if @pinta == "E"
    return "Trebol" if @pinta == "T"
  end

  En esta clase no hay mucho que decir. 


  ---LA CAJA NEGRA DE LA CLASE Baraja---

  La Clase Baraja habilita los métodos attr_reader y attr_writer, contiene además el metodo constructor, el metodo repartirMano
  el método sacar y adicionalmente el metodo ordenar.

  ---EL METODO CONSTRUCTOR---

  Este metodo es algo particular, dado que al momento de crear la baraja, instancia la clase Carta, con todas las posibilidades 
  de combinación de numero y pinta. Para lograr esto se utiliza un arreglo con las pintas posibles, el cual se recorre con el
  metodo each, además se utiliza un ciclo for en el cual se agregan los numeros del 1 al 13 en la medida que se incrementa el iterador.
  Al finalizar el metodo constructor queda creada la baraja con 52 cartas. 
  Para el almacenar el numero total de cartas se utiliza la variable de instancia @totalCartas. 
  
  def initialize(cartas=[],manoObj=[])
    arrayPinta = ["C", "D", "E", "T"]
    @totalCartas = 0 #contador de cartas
    arrayPinta.each do |pinta|
    @cartas = cartas
    @manoObj = manoObj
      for idx in (1..(13))
        @cartas.push(Carta.new(idx, pinta))
        @totalCartas += 1
        # print "#{@cartas}"
      end
    end 
  end

---EL METODO BARAJAR---
Este es un metodo muy pequeño que utiliza el metodo de array shuffle para reorganizar el contenido de la variable de
instancia @cartas, la cual como sabemos es un arreglo que contiene todas instancias de la clase Carta instanciadas
por el metodo constructor. 
    
    @cartas.shuffle!


---EL METODO repartir_Mano---

Siguiendo la linea de utlizar metodos de la clase Array, para resolver los requerimeintos, para repartir una mano 
se utiliza el metodo shift, el cual extrae el primer elemento de un arreglo. a pesar de que en la descripción del desafío se sugiere
la utilización pop, esta opción se descarta, dado que revisando la documentación esta indica que pop sirve para extraer
el ultimo elemento de un arreglo. 

    @manoObj.push(@cartas.shift)

    esta linea extrae el primer elemento de la variable de clase Array y lo asigna a un arreglo de objetos que contrendrá
    las 5 cartas repartidas.

En la medida que va asignando las cartas. se va actualizando la variable totalCartas, la cual almacena la cantidad de cartas
que quedan en la baraja. Es decir, si reparte 5 cartas le resta 5 a totalCartas

llevar el conteo de las cartas que quedan en la baraja, permite saber si se puede seguir repartiendo cartas o si ya se acabaron.

---EL METODO sacar---

al igual que metodo anterior utiliza el metodo de Array shift para extraer la primera carta y actualiza
la variable totalCartas.

    def sacar
        if @totalCartas >= 1
            @totalCartas -= 1
            @cartas.shift
        else 
            puts "No quedan cartas en el mazo"
        end
    end


---EL METODO ordenar---

Finalmente, se crea este metodo para poder volver a utilizar la baraja. Para ello, llama al metodo initialize.

    def ordenar 
        initialize()
        return "baraja ordenada"
    end

